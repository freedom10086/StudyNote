深克隆与浅克隆
大家知道，对象是互相引用的，即对象中可能包含了另一个对象的引用，举例如：有一个Order对象，Order对象中又包含了LineItems对象，然后LineItems对象又包含了Item对象。
好了，现在我有一个Order对象order1,它包含了一个LineItems对象items，这表示的是有一个订单order1，订单的内容是items。
好的，现在有另一个客户想要一份订单，内容跟order1完全一样，那么在系统的逻辑层我们怎么做呢？很简单，order2=order1.clone(). 我们知道clone方法是在内存中生成一个新的对象，而不是只得到原对象的引用。这时候，有人说话了：“哦，明白了我们对order2的成员变量进行修改，是不会影响order1的。” 很可惜，这句话只对了一半。
假设order类有一个成员变量name，当然改变order2.name不会影响order1.name，因为他们在不同的内存区域。但是如果改变 order1.items呢？很遗憾，简单地使用order1.clone，是会影响到order2.items的。原因很简单，就是因为clone方法默认的是浅克隆，即不会克隆对象引用的对象，而只是简单地复制这个引用。所以在上例中，items对象在内存中只有一个，order1和order2都指向它，任何一个对象对它的修改都会影响另一个对象。
那相对浅克隆，深克隆自然就是会克隆对象引用的对象了。也就是说，在上例中，改变order1.items并不会影响order2.items了。因为内存中有两个一样的items。
如果实现深克隆？
一个方法自然是重写clone方法，添加如order.items=(LineItems)items.clone()的语句，也就是人为地添加对引用对象的复制。这个方法的缺点是如果引用对象有很多，或者说引用套引用很多重，那么太麻烦了。业界常用的方法是使用串行化然后反串行化的方法来实现深克隆。由于串行化后，对象写到流中，所有引用的对象都包含进来了，所以反串行化后，对等于生成了一个完全克隆的对象。绝！
这个方法的要求是对象（包括被引用对象）必须事先了Serializable接口，否则就要用transient关键字将其排除在复制过程中。